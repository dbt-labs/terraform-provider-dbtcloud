package resources

import (
	"context"
	"fmt"
	"strings"

	"github.com/dbt-labs/terraform-provider-dbtcloud/pkg/dbt_cloud"
	"github.com/dbt-labs/terraform-provider-dbtcloud/pkg/helper"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func ResourceRepository() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceRepositoryCreate,
		ReadContext:   resourceRepositoryRead,
		UpdateContext: resourceRepositoryUpdate,
		DeleteContext: resourceRepositoryDelete,

		Schema: map[string]*schema.Schema{
			"repository_id": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Repository Identifier",
			},
			"is_active": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     true,
				Description: "Whether the repository is active",
			},
			"project_id": {
				Type:        schema.TypeInt,
				Required:    true,
				ForceNew:    true,
				Description: "Project ID to create the repository in",
			},
			"remote_url": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Git URL for the repository or \\<Group>/\\<Project> for Gitlab",
			},
			"git_clone_strategy": {
				Type:        schema.TypeString,
				Optional:    true,
				Default:     "deploy_key",
				ForceNew:    true,
				Description: "Git clone strategy for the repository. Can be `deploy_key` (default) for cloning via SSH Deploy Key, `github_app` for GitHub native integration, `deploy_token` for the GitLab native integration and `azure_active_directory_app` for ADO native integration",
			},
			"repository_credentials_id": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Credentials ID for the repository (From the repository side not the dbt Cloud ID)",
			},
			"gitlab_project_id": {
				Type:        schema.TypeInt,
				Optional:    true,
				ForceNew:    true,
				Description: "Identifier for the Gitlab project -  (for GitLab native integration only)",
			},
			"github_installation_id": {
				Type:        schema.TypeInt,
				Optional:    true,
				ForceNew:    true,
				Description: "Identifier for the GitHub App - (for GitHub native integration only)",
			},
			"azure_active_directory_project_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Default:     "",
				ForceNew:    true,
				Description: "The Azure Dev Ops project ID. It can be retrieved via the Azure API or using the data source `dbtcloud_azure_dev_ops_project` and the project name - (for ADO native integration only)",
			},
			"azure_active_directory_repository_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Default:     "",
				ForceNew:    true,
				Description: "The Azure Dev Ops repository ID. It can be retrieved via the Azure API or using the data source `dbtcloud_azure_dev_ops_repository` along with the ADO Project ID and the repository name - (for ADO native integration only)",
			},
			"azure_bypass_webhook_registration_failure": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				ForceNew:    true,
				Description: "If set to False (the default), the connection will fail if the service user doesn't have access to set webhooks (required for auto-triggering CI jobs). If set to True, the connection will be successful but no automated CI job will be triggered - (for ADO native integration only)",
			},
			"fetch_deploy_key": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Whether we should return the public deploy key - (for the `deploy_key` strategy)",
				Deprecated:  "This field is deprecated and will be removed in a future version of the provider, please remove it from your configuration. The key is always fetched when the clone strategy is `deploy_key`",
			},
			"deploy_key": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Public key generated by dbt when using `deploy_key` clone strategy",
			},
			"pull_request_url_template": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "URL template for creating a pull request. If it is not set, the default template will create a PR from the current branch to the branch configured in the Development environment.",
			},
		},

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceRepositoryCreate(
	ctx context.Context,
	d *schema.ResourceData,
	m interface{},
) diag.Diagnostics {
	c := m.(*dbt_cloud.Client)

	var diags diag.Diagnostics

	isActive := d.Get("is_active").(bool)
	projectId := d.Get("project_id").(int)
	remoteUrl := d.Get("remote_url").(string)
	gitCloneStrategy := d.Get("git_clone_strategy").(string)
	gitlabProjectID := d.Get("gitlab_project_id").(int)
	githubInstallationID := d.Get("github_installation_id").(int)
	azureActiveDirectoryProjectID := d.Get("azure_active_directory_project_id").(string)
	azureActiveDirectoryRepositoryID := d.Get("azure_active_directory_repository_id").(string)
	azureBypassWebhookRegistrationFailure := d.Get("azure_bypass_webhook_registration_failure").(bool)
	pullRequestURLTemplate := d.Get("pull_request_url_template").(string)

	repository, err := c.CreateRepository(
		projectId,
		remoteUrl,
		isActive,
		gitCloneStrategy,
		gitlabProjectID,
		githubInstallationID,
		azureActiveDirectoryProjectID,
		azureActiveDirectoryRepositoryID,
		azureBypassWebhookRegistrationFailure,
		pullRequestURLTemplate,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	// checking potential issues with the creation of GitLab repositories with service tokens
	if repository.RepositoryCredentialsID == nil && gitlabProjectID != 0 {

		repositoryIDString := fmt.Sprintf("%d", *repository.ID)
		projectIDString := fmt.Sprintf("%d", repository.ProjectID)
		_, err := c.DeleteRepository(repositoryIDString, projectIDString)
		if err != nil {
			return diag.FromErr(err)
		}

		return diag.FromErr(
			fmt.Errorf(
				"`repository_credentials_id` is not set after creating the repository. This is likely due to creating the repository with a service token. Only user tokens / personal access tokens are supported for GitLab at the moment",
			),
		)
	}

	d.SetId(fmt.Sprintf("%d%s%d", repository.ProjectID, dbt_cloud.ID_DELIMITER, *repository.ID))

	resourceRepositoryRead(ctx, d, m)

	return diags
}

func resourceRepositoryRead(
	ctx context.Context,
	d *schema.ResourceData,
	m interface{},
) diag.Diagnostics {
	c := m.(*dbt_cloud.Client)

	var diags diag.Diagnostics
	projectIdString, repositoryIdString, err := helper.SplitIDToStrings(
		d.Id(),
		"dbtcloud_repository",
	)
	if err != nil {
		return diag.FromErr(err)
	}

	repository, err := c.GetRepository(repositoryIdString, projectIdString)
	if err != nil {
		if strings.HasPrefix(err.Error(), "resource-not-found") {
			d.SetId("")
			return diags
		}
		return diag.FromErr(err)
	}

	if err := d.Set("repository_id", repository.ID); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("is_active", repository.State == dbt_cloud.STATE_ACTIVE); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("project_id", repository.ProjectID); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("remote_url", repository.RemoteUrl); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("git_clone_strategy", repository.GitCloneStrategy); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("repository_credentials_id", repository.RepositoryCredentialsID); err != nil {
		return diag.FromErr(err)
	}
	// CC-709: we currently don't get back the GitLab project ID from the API
	if err := d.Set("gitlab_project_id", d.Get("gitlab_project_id").(int)); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("github_installation_id", repository.GithubInstallationID); err != nil {
		return diag.FromErr(err)
	}
	if repository.DeployKey != nil {
		if err := d.Set("deploy_key", repository.DeployKey.PublicKey); err != nil {
			return diag.FromErr(err)
		}
	}
	// the following values are not sent back by the API so we set them as they are in the config
	if err := d.Set("azure_active_directory_project_id", d.Get("azure_active_directory_project_id").(string)); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("azure_active_directory_repository_id", d.Get("azure_active_directory_repository_id").(string)); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("azure_bypass_webhook_registration_failure", d.Get("azure_bypass_webhook_registration_failure").(bool)); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("pull_request_url_template", repository.PullRequestURLTemplate); err != nil {
		return diag.FromErr(err)
	}

	return diags
}

func resourceRepositoryUpdate(
	ctx context.Context,
	d *schema.ResourceData,
	m interface{},
) diag.Diagnostics {
	c := m.(*dbt_cloud.Client)

	projectIdString, repositoryIdString, err := helper.SplitIDToStrings(
		d.Id(),
		"dbtcloud_repository",
	)
	if err != nil {
		return diag.FromErr(err)
	}

	if d.HasChange("is_active") || d.HasChange("pull_request_url_template") {
		repository, err := c.GetRepository(repositoryIdString, projectIdString)
		if err != nil {
			return diag.FromErr(err)
		}

		if d.HasChange("is_active") {
			isActive := d.Get("is_active").(bool)
			if isActive {
				repository.State = dbt_cloud.STATE_ACTIVE
			} else {
				repository.State = dbt_cloud.STATE_DELETED
			}
		}
		if d.HasChange("pull_request_url_template") {
			repository.PullRequestURLTemplate = d.Get("pull_request_url_template").(string)
		}

		_, err = c.UpdateRepository(repositoryIdString, projectIdString, *repository)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return resourceRepositoryRead(ctx, d, m)
}

func resourceRepositoryDelete(
	ctx context.Context,
	d *schema.ResourceData,
	m interface{},
) diag.Diagnostics {
	c := m.(*dbt_cloud.Client)

	var diags diag.Diagnostics

	projectIdString, repositoryIdString, err := helper.SplitIDToStrings(
		d.Id(),
		"dbtcloud_repository",
	)
	if err != nil {
		return diag.FromErr(err)
	}

	_, err = c.DeleteRepository(repositoryIdString, projectIdString)
	if err != nil {
		return diag.FromErr(err)
	}

	return diags
}
